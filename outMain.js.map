{
  "version": 3,
  "sources": ["main.ts"],
  "sourcesContent": ["import { promises as fs } from 'fs';\n\nasync function jobArrived(s: Switch, flowElement: FlowElement, job: Job) {\n    //get variables from script element\n    let datasetName: string = await flowElement.getPropertyStringValue(\"datasetName\") as string;\n    let keyAndJSONpaths: string | string[] = await flowElement.getPropertyStringValue(\"keyAndJSONpaths\") as string[];\n\n    //get data\n    let filePath = await job.getDataset(datasetName, AccessLevel.ReadWrite);\n    let data = await fs.readFile(filePath, 'utf8');\n    let jsonData = JSON.parse(data);\n    await job.log(LogLevel.Info, jsonData);\n\n    //get the data from the path or keyAndJSONpaths\n    let keyAndJSONpath: string | undefined;\n\n    if (typeof keyAndJSONpaths === 'string') {\n        await job.log(LogLevel.Warning, `Path is a single string ${keyAndJSONpaths}`);\n        keyAndJSONpaths[0] = keyAndJSONpaths;\n    }\n    else if (Array.isArray(keyAndJSONpaths) && keyAndJSONpaths.every(path => typeof path === 'string')) {\n        await job.log(LogLevel.Warning, `Path is an array ${keyAndJSONpaths}`);\n    }\n    else {\n        await job.log(LogLevel.Error, `${keyAndJSONpaths} is neither a string nor an array of strings. It cannot be processed`);\n        keyAndJSONpaths = '';\n    }\n\n    //get the data\n    function getValueByPath(jsonData: Record<string, any>, keyAndJSONpath: string): any {\n        return keyAndJSONpath\n            .replace(/\\[(\\d+)\\]/g, '.$1') // Convert \"[0]\" into \".0\"\n            .split('.')                    // Now split normally\n            .reduce((acc, key) => acc?.[key], jsonData);\n    }\n\n    //loop through keyAndJSONpaths logging each returned value\n    for (const keyAndJSONpath of keyAndJSONpaths) {\n        const [pdkey, JSONpath] = keyAndJSONpath.split(\"::\");\n        const value = getValueByPath(jsonData, JSONpath);\n        await job.setPrivateData(pdkey, value);\n        await job.log(LogLevel.Warning, \n            `Path \"${JSONpath}\" produced extracted value: ${value} which will be set to private data key ${pdkey}`\n        );\n    }\n\n    // //loop through keyAndJSONpaths logging each returned value\n    // for (const path of keyAndJSONpaths) {\n    //     const value = getValueByPath(jsonData, path);\n    //     await job.log(LogLevel.Warning, `Path \"${path}\" produced extracted value: ${value}`);\n    // }\n\n    await job.sendToSingle();\n}\n"],
  "mappings": ";;;;AAAA,IAAA,OAAA,QAAA,IAAA;AAEA,eAAe,WAAW,GAAW,aAA0B,KAAQ;AAEnE,MAAI,cAAsB,MAAM,YAAY,uBAAuB,aAAa;AAChF,MAAI,kBAAqC,MAAM,YAAY,uBAAuB,OAAO;AAGzF,MAAI,WAAW,MAAM,IAAI,WAAW,aAAa,YAAY,SAAS;AACtE,MAAI,OAAO,MAAM,KAAA,SAAG,SAAS,UAAU,MAAM;AAC7C,MAAI,WAAW,KAAK,MAAM,IAAI;AAC9B,QAAM,IAAI,IAAI,SAAS,MAAM,QAAQ;AAGrC,MAAI;AAEJ,MAAI,OAAO,oBAAoB,UAAU;AACrC,UAAM,IAAI,IAAI,SAAS,SAAS,2BAA2B,eAAe,EAAE;AAC5E,oBAAgB,CAAC,IAAI;aAEhB,MAAM,QAAQ,eAAe,KAAK,gBAAgB,MAAM,UAAQ,OAAO,SAAS,QAAQ,GAAG;AAChG,UAAM,IAAI,IAAI,SAAS,SAAS,oBAAoB,eAAe,EAAE;SAEpE;AACD,UAAM,IAAI,IAAI,SAAS,OAAO,GAAG,eAAe,sEAAsE;AACtH,sBAAkB;;AAItB,WAAS,eAAeA,WAA+BC,iBAAsB;AACzE,WAAOA,gBACF,QAAQ,cAAc,KAAK,EAC3B,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,QAAG,QAAH,QAAG,SAAA,SAAH,IAAM,GAAG,GAAGD,SAAQ;EAClD;AAGA,aAAWC,mBAAkB,iBAAiB;AAC1C,UAAM,CAAC,OAAO,QAAQ,IAAIA,gBAAe,MAAM,IAAI;AACnD,UAAM,QAAQ,eAAe,UAAU,QAAQ;AAC/C,UAAM,IAAI,eAAe,OAAO,KAAK;AACrC,UAAM,IAAI,IAAI,SAAS,SACnB,SAAS,QAAQ,+BAA+B,KAAK,0CAA0C,KAAK,EAAE;;AAU9G,QAAM,IAAI,aAAY;AAC1B;",
  "names": ["jsonData", "keyAndJSONpath"]
}
